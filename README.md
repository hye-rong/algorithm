# algorithm

## 01 Greedy(그리디)
**그리디 알고리즘이란?**
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 문제에서 "가장 큰 순서대로" 과 같이 기준을 제시해줌
- 문제 풀이를 위한 아이디어를 떠올리고 정당성을 검토해야함
- 정당성은 탐욕적으로 풀었을 때 정확한 답을 보장하는지 확인하는 것
- ex) 거스름돈 문제에서 가장 큰 화폐부터 거슬러 주는 것



## 02 Implementation(구현)
**(코딩테스트에서)구현이란?**
- 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정
- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 의미
- 문법을 잘 이해하고 경험이 있어야지 문제를 잘 푸는 유형
- 완전 탐색(모든 경우의 수 고려), 시뮬레이션(제시된 알고리즘 차례로 수행)등 유형 존재
- 파이썬에서는 리스트 메모리 제한을 고려해야 함


## 03 Graph Traversal
**그래프 표현 방식**
- 인접 행렬: 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  -> 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 낭비
  -> 연결 정보 바로 접근해서 빠르게 정보 얻음
- 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식
  -> 연결 정보만 저장하므로 메모리 효율적으로 사용
  -> 두 노드의 연결 여부 정보 얻는 속도 느림
 - 2차원 배열의 탐색 문제를 그래프 형태로 바꿔서 풀이할 수 있다

**DFS**
- 깊이 우선 탐색: 그래프의 깊은 부분을 우선적으로 탐색
- 스택을 이용해서 구현
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2.1 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 스택에 넣고 방문 처리
2.2 방문하지 않은 인접 노드가 없으면, 스택에서 최상단 노드를 꺼냄
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

**BFS**
- 너비 우선 탐색: 가까운 노드부터 탐색하는 알고리즘
- 선입선출의 큐를 이용해서 구현
- 일반적인 경우 실제 수행시간은 DFS보다 좋은 편
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
2. 큐에 노드를 꺼내 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복
